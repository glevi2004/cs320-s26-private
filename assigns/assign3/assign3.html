<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<!-- 2026-02-07 Sat 11:48 -->
<meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Assignment 3</title>
<meta name="author" content="Nathan" />
<meta name="generator" content="Org Mode" />
<link rel="stylesheet" type="text/css" href="../../style.css" />
<script>
  window.MathJax = {
    tex: {
      ams: {
        multlineWidth: '85%'
      },
      tags: 'ams',
      tagSide: 'right',
      tagIndent: '.8em'
    },
    chtml: {
      scale: 1.0,
      displayAlign: 'center',
      displayIndent: '0em'
    },
    svg: {
      scale: 1.0,
      displayAlign: 'center',
      displayIndent: '0em'
    },
    output: {
      font: 'mathjax-modern',
      displayOverflow: 'overflow'
    }
  };
</script>

<script
  id="MathJax-script"
  async
  src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js">
</script>
</head>
<body>
<div id="org-div-home-and-up">[<a href="https://bu-cs320.github.io/cs320-s26/">back</a>]</div><div id="content" class="content">
<h1 class="title">Assignment 3</h1>
<div id="table-of-contents" role="doc-toc">
<h2>Table of Contents</h2>
<div id="text-table-of-contents" role="doc-toc">
<ul>
<li><a href="#orga63a0ca">1. Programming</a>
<ul>
<li><a href="#org09386ce">1.1. Lexing</a></li>
<li><a href="#orgac55ffc">1.2. Evaluation</a></li>
<li><a href="#org289550e">1.3. Unique Insertion</a></li>
</ul>
</li>
<li><a href="#org5dd810b">2. Written</a>
<ul>
<li><a href="#org71b38fd">2.1. Typing Derivations</a></li>
<li><a href="#org4e4f343">2.2. Semantic Derivations</a></li>
<li><a href="#orgd40ff17">2.3. Recursive Let-Expressions</a></li>
</ul>
</li>
</ul>
</div>
</div>
<p>
This assignment is due on <b>Thursday 2/12 by 8:00PM</b>.  You should put
all of your programming solutions in a file called
<code>assign3/lib/assign3.ml</code>. See the file <code>test/test_assign3.ml</code> for
example behavior of each function.  Your written solutions should be
submitted via Gradescope as a single pdf.  They must be exceptionally
neat (or typed) and the final answer in your solution to each problem
must be abundantly clear, e.g., surrounded in a box.  Also make sure
to cite your sources per the instructions in the course manual.
</p>
<div id="outline-container-orga63a0ca" class="outline-2">
<h2 id="orga63a0ca"><span class="section-number-2">1.</span> Programming</h2>
<div class="outline-text-2" id="text-1">
<p>
This week you'll be building (surprise) a calculator.  Or rather,
you'll be extending the calculator from the previous assignment so
that values can be assigned to variables.  The inputs to this
calculator are statements of the form
</p>

<div class="org-src-container">
<pre class="src src-txt">VARIABLE = &lt;expr&gt;
</pre>
</div>

<p>
where <code>VARIABLE</code> is a variable name composed solely of upper-case
letters and <code>&lt;expr&gt;</code> is an infix arithmetic expression as in
assignment 2 but potentially with variables.  So, for example, after
you've implemented the following functions you should be able to have
the following interaction via <code>dune exec assign3</code>:
</p>

<div class="org-src-container">
<pre class="src src-txt">ArithVar version 0.0.1
Enter #quit;; to exit

# X = 2 * 2;;
- : int = 4
#      Y     =     3  *     4;;
- : int = 12
# ADDXY
  =
  X
  +
  Y
  ;;
- : int = 16
</pre>
</div>

<p>
There are several functions to implement, but you should take
assignment 2 as a staring point.
</p>
</div>
<div id="outline-container-org09386ce" class="outline-3">
<h3 id="org09386ce"><span class="section-number-3">1.1.</span> Lexing</h3>
<div class="outline-text-3" id="text-1-1">
<p>
Implement the function
</p>
<div class="org-src-container">
<pre class="src src-ocaml"><span style="color: #000000; font-weight: bold;">val</span> <span style="color: #0000ff;">lex</span> : string -&gt; string list
</pre>
</div>
<p>
so that <code>lex input</code> is the result of removing the whitespace from
<code>input</code> and separating it into its constituent parts (formally called
<b>lexemes</b>). These parts consist of: <code>(</code>, <code>)</code>, <code>+</code>, <code>-</code>, <code>*</code>, <code>/</code>, <code>=</code>,
nonnegative integers (i.e. contiguous groups of digits) and variables
(i.e., contiguous groups of upper-case letters), e.g.,
</p>

<div class="org-src-container">
<pre class="src src-nil">let _ = assert (lex "VAR = 2 + 3" = ["VAR"; "="; "2"; "+"; "3"])
</pre>
</div>

<p>
The behavior of the function is undefined if the input is not a
well-formed statement as described above.
</p>
</div>
</div>
<div id="outline-container-orgac55ffc" class="outline-3">
<h3 id="orgac55ffc"><span class="section-number-3">1.2.</span> Evaluation</h3>
<div class="outline-text-3" id="text-1-2">
<p>
Evaluation is roughly the same as in assignment 2, except that now
it's possible that the given expression contains variables.  We'll be
using association lists to represent variable bindings that we create
during a calculator interaction.  An association list is a list of
key-value pairs (<code>('k * 'v) list</code>).  See the <a href="https://cs3110.github.io/textbook/chapters/data/assoc_list.html">textbook chapter</a> and the
<a href="https://nmmull.github.io/stdlib320/stdlib320/Stdlib320/List/index.html#association-lists"><code>stdlib320</code> section</a> for more information.  For the above sample
interaction the final assocation list we should get up to reordering
is:
</p>

<div class="org-src-container">
<pre class="src src-nil">[("X", 4); ("Y", 12); ("ADDXY", 16)]
</pre>
</div>


<p>
Implement the function
</p>

<div class="org-src-container">
<pre class="src src-ocaml"><span style="color: #000000; font-weight: bold;">val</span> <span style="color: #0000ff;">eval</span> : (string * int) list -&gt; string list -&gt; int
</pre>
</div>
<p>
so that <code>eval env expr</code> is the result of evaluating an arithmetic
expression <code>expr</code> in infix notation with variables (i.e., the
right-hand side of the <code>"="</code> after lexing) relative to the variable
bindings in <code>env</code>, e.g.,
</p>

<div class="org-src-container">
<pre class="src src-nil">let _ = assert (eval [("X", 4); ("Y", 12)] ["X"; "+"; "Y"] = 16)
</pre>
</div>

<p>
The behavior of the function is undefined if <code>expr</code> is not a valid
arithmetic expression in infix notation with variables post-lexing.
</p>
</div>
</div>
<div id="outline-container-org289550e" class="outline-3">
<h3 id="org289550e"><span class="section-number-3">1.3.</span> Unique Insertion</h3>
<div class="outline-text-3" id="text-1-3">
<p>
After evaluating an expression, we'll need to add it to the variable
bindings maintained by the calculator.  Implement the function
</p>

<div class="org-src-container">
<pre class="src src-nil">val insert_uniq : 'k -&gt; 'v -&gt; ('k * 'v) list -&gt; ('k * 'v) list
</pre>
</div>

<p>
so that <code>insert_uniq k v l</code> is the result of inserting <code>(k, v)</code> into
<code>l</code>.  Furthermore, your implementation must maintain the invariant
that <i>a key appears at most once in the resulting list</i>. Furthermore
furthermore, your implementation must be tail recursive.  <b>Note:</b> The
order of key-value pairs does <i>not</i> need to be maintained in the
resulting list.
</p>

<div class="org-src-container">
<pre class="src src-nil">let l = [("X", 4); ("Y", 12); ("ADDXY", 16)]
let _ = assert (List.assoc "X" l = 4)
let _ = assert (List.assoc "X" (insert_uniq "X" 7 l) = 7)
</pre>
</div>
</div>
</div>
</div>
<div id="outline-container-org5dd810b" class="outline-2">
<h2 id="org5dd810b"><span class="section-number-2">2.</span> Written</h2>
<div class="outline-text-2" id="text-2">
<p>
For all derivations, make sure that you label every rule instantiation
with a rule name, and that you do <i>not</i> include side-conditions.  The
rules you should use for your derivations are included in the notes
for this course under the section <b>320Caml Specification</b>.
</p>
</div>
<div id="outline-container-org71b38fd" class="outline-3">
<h3 id="org71b38fd"><span class="section-number-3">2.1.</span> Typing Derivations</h3>
<div class="outline-text-3" id="text-2-1">
<ol class="org-ol">
<li><p>
Determine a type \(\tau\) such that the following typing judgment is
derivable.  Also provide the derivation.
</p>

<p>
\[
   \{ \texttt{f} : \texttt{int -> bool} \} \vdash \texttt{let x = let y = 3 in y + y in f x} : \tau
   \]
</p></li>

<li><p>
Determine a type \(\tau\) such that the following typing judgment is
derivable.  Also provide the derivation.
</p>

<p>
\[
   \{\} \vdash \texttt{(fun x -> fun y -> y x) (fun x -> x) (fun f -> f 1)} : \tau
   \]
</p></li>
</ol>
</div>
</div>
<div id="outline-container-org4e4f343" class="outline-3">
<h3 id="org4e4f343"><span class="section-number-3">2.2.</span> Semantic Derivations</h3>
<div class="outline-text-3" id="text-2-2">
<ol class="org-ol">
<li><p>
Determine a value \(v\) such that the following semantic judgment is
derivable.  Also provide the derivation.
</p>

<p>
\[
   \texttt{let x = 3 in if x = 4 then x + 1 else x + 2} \Downarrow v
   \]
</p></li>
<li><p>
Determine a value \(v\) such that the following semantic judgment is
derivable.  Also provide the derivation.
</p>

<p>
\[
   \texttt{let x = let y = 3 + 3 in x} \Downarrow v
   \]
</p></li>
</ol>
</div>
</div>
<div id="outline-container-orgd40ff17" class="outline-3">
<h3 id="orgd40ff17"><span class="section-number-3">2.3.</span> Recursive Let-Expressions</h3>
<div class="outline-text-3" id="text-2-3">
<p>
One rule not included in the 320Caml specification is the typing rule
for recursive let expressions, which have the following syntax:
</p>

<div class="org-src-container">
<pre class="src src-txt">&lt;expr&gt; ::= let rec &lt;var&gt; = &lt;expr&gt; in &lt;expr&gt;
</pre>
</div>

<p>
The only difference between the let rule and the recursive let rule is
that, given an expression of form:
</p>

<p>
\[
\texttt{let} \ \texttt{rec}\ f \ \texttt{=} \ e_1 \ \texttt{in} \ e_2
\]
</p>

<p>
determining the type of \(e_1\) requires that \(f\) appears in the
context, since the definition of a recursive function can depend on
the function itself.
</p>

<p>
Provide the typing rule for recursive let statements (we'll call it <b>LetRec</b>),
and use this to give a derivation of the following typing judgment.
</p>

<p>
\[
\{\} \vdash \texttt{let rec f = fun x -> f (x + 1) = 0 in f} : \texttt{int -> bool}
\]
</p>
</div>
</div>
</div>
</div>
</body>
</html>
